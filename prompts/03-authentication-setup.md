# Step 3: Authentication Setup with NextAuth.js

## Overview

This plan outlines the process of setting up authentication in the NoteMomad application using NextAuth.js. We'll implement two authentication methods: username/password credentials and magic link authentication. We'll also set up email templates using React Email and Resend for sending verification and magic link emails.

## Prerequisites

- T3 stack application with NextAuth.js already installed
- Prisma ORM with the required models
- PostgreSQL database correctly configured
- ShadCN UI components installed

## Implementation Steps

### 1. Verify NextAuth Installation and Setup

The T3 stack comes with NextAuth pre-installed, but let's ensure it's up to date and properly configured:

```bash
# Check NextAuth version (should be v5+)
npm list next-auth

# If needed, update to NextAuth v5
npm install next-auth@latest @auth/prisma-adapter@latest
```

### 2. Set Up Resend for Email Services

```bash
# Install Resend SDK
npm install resend

# Install React Email for email templates
npm install @react-email/components
```

### 3. Configure Environment Variables

Update your `.env` file with the necessary variables for authentication and email:

```
# NextAuth Configuration
AUTH_SECRET="your-secret-key"  # Already generated by T3 app
AUTH_URL="http://localhost:3000"  # For development

# Resend Email Service
RESEND_API_KEY="your-resend-api-key"  # Get from Resend dashboard
EMAIL_FROM="noreply@yourdomain.com"
```

### 4. Create Email Templates with React Email

Create a directory for email templates:

```bash
mkdir -p src/emails
```

#### Magic Link Email Template

Create `src/emails/magic-link-email.tsx`:

```tsx
import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Html,
  Link,
  Preview,
  Section,
  Text,
} from "@react-email/components";

interface MagicLinkEmailProps {
  magicLink: string;
  host: string;
}

export const MagicLinkEmail = ({ magicLink, host }: MagicLinkEmailProps) => {
  return (
    <Html>
      <Head />
      <Preview>Your magic link for NoteMomad</Preview>
      <Body style={{ fontFamily: "Arial, sans-serif" }}>
        <Container>
          <Heading>Login to NoteMomad</Heading>
          <Section>
            <Text>
              Click the button below to sign in to NoteMomad. This link will
              expire in 10 minutes.
            </Text>
            <Button
              href={magicLink}
              style={{
                backgroundColor: "#4A86E8",
                color: "#fff",
                padding: "12px 20px",
                borderRadius: "3px",
              }}
            >
              Sign in to NoteMomad
            </Button>
            <Text>
              If you did not request this link, you can safely ignore this
              email.
            </Text>
            <Text>
              If the button above doesn't work, you can also copy and paste this
              URL into your browser:
            </Text>
            <Link href={magicLink}>{magicLink}</Link>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};

export default MagicLinkEmail;
```

#### Verification Email Template

Create `src/emails/verification-email.tsx`:

```tsx
import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Html,
  Link,
  Preview,
  Section,
  Text,
} from "@react-email/components";

interface VerificationEmailProps {
  verificationLink: string;
  host: string;
}

export const VerificationEmail = ({
  verificationLink,
  host,
}: VerificationEmailProps) => {
  return (
    <Html>
      <Head />
      <Preview>Verify your email for NoteMomad</Preview>
      <Body style={{ fontFamily: "Arial, sans-serif" }}>
        <Container>
          <Heading>Verify your email</Heading>
          <Section>
            <Text>
              Click the button below to verify your email address for NoteMomad.
              This link will expire in 24 hours.
            </Text>
            <Button
              href={verificationLink}
              style={{
                backgroundColor: "#4A86E8",
                color: "#fff",
                padding: "12px 20px",
                borderRadius: "3px",
              }}
            >
              Verify Email
            </Button>
            <Text>
              If you did not create an account with NoteMomad, you can safely
              ignore this email.
            </Text>
            <Text>
              If the button above doesn't work, you can also copy and paste this
              URL into your browser:
            </Text>
            <Link href={verificationLink}>{verificationLink}</Link>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};

export default VerificationEmail;
```

### 5. Set Up Resend Email Service

Create a utility file for sending emails at `src/lib/email.ts`:

```typescript
import { Resend } from "resend";
import MagicLinkEmail from "@/emails/magic-link-email";
import VerificationEmail from "@/emails/verification-email";
import { env } from "@/env";

const resend = new Resend(env.RESEND_API_KEY);

export const sendMagicLinkEmail = async (email: string, magicLink: string) => {
  const { error } = await resend.emails.send({
    from: env.EMAIL_FROM,
    to: email,
    subject: "Your NoteMomad Magic Link",
    react: MagicLinkEmail({
      magicLink,
      host: env.AUTH_URL,
    }),
  });

  if (error) {
    console.error("Failed to send magic link email:", error);
    throw new Error("Failed to send magic link email");
  }
};

export const sendVerificationEmail = async (
  email: string,
  verificationLink: string,
) => {
  const { error } = await resend.emails.send({
    from: env.EMAIL_FROM,
    to: email,
    subject: "Verify your NoteMomad account",
    react: VerificationEmail({
      verificationLink,
      host: env.AUTH_URL,
    }),
  });

  if (error) {
    console.error("Failed to send verification email:", error);
    throw new Error("Failed to send verification email");
  }
};
```

### 6. Update Environment Variables Validation

Update your `src/env.js` file to include the new environment variables:

```javascript
// Existing import statements

export const env = createEnv({
  server: {
    // Add these new variables
    RESEND_API_KEY: z.string().min(1),
    EMAIL_FROM: z.string().email(),
    AUTH_URL: z.string().url(),
    // Keep existing variables...
    AUTH_SECRET: z.string().min(1),
    // ...other variables
  },
  // Keep other configurations as they are
});
```

### 7. Configure NextAuth.js for Authentication

Create or update the Auth configuration at `src/server/auth.ts`:

```typescript
import { PrismaAdapter } from "@auth/prisma-adapter";
import {
  getServerSession,
  type DefaultSession,
  type NextAuthConfig,
} from "next-auth";
import { use } from "next-auth";
import Credentials from "next-auth/providers/credentials";
import EmailProvider from "next-auth/providers/email";
import { z } from "zod";
import bcrypt from "bcryptjs";

import { db } from "@/server/db";
import { env } from "@/env";
import { sendMagicLinkEmail, sendVerificationEmail } from "@/lib/email";

/**
 * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`
 * object and keep type safety.
 *
 * @see https://next-auth.js.org/getting-started/typescript#module-augmentation
 */
declare module "next-auth" {
  interface Session extends DefaultSession {
    user: {
      id: string;
      // ...other properties
    } & DefaultSession["user"];
  }
}

/**
 * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.
 *
 * @see https://next-auth.js.org/configuration/options
 */
export const authConfig = {
  callbacks: {
    session: ({ session, user }) => ({
      ...session,
      user: {
        ...session.user,
        id: user.id,
      },
    }),
  },
  adapter: PrismaAdapter(db),
  providers: [
    EmailProvider({
      async sendVerificationRequest({ identifier: email, url }) {
        await sendMagicLinkEmail(email, url);
      },
    }),
    Credentials({
      id: "credentials",
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        const parsedCredentials = z
          .object({ email: z.string().email(), password: z.string().min(6) })
          .safeParse(credentials);

        if (!parsedCredentials.success) {
          throw new Error("Invalid credentials");
        }

        const { email, password } = parsedCredentials.data;
        const user = await db.user.findUnique({
          where: { email },
        });

        if (!user || !user.password) {
          throw new Error("User not found or invalid login method");
        }

        const passwordValid = await bcrypt.compare(password, user.password);
        if (!passwordValid) {
          throw new Error("Invalid password");
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
        };
      },
    }),
  ],
  pages: {
    signIn: "/auth/signin",
    verifyRequest: "/auth/verify-request",
    newUser: "/auth/new-user",
  },
} satisfies NextAuthConfig;

/**
 * Wrapper for `getServerSession` so that you don't need to import the `authConfig` in every file.
 *
 * @see https://next-auth.js.org/configuration/nextjs
 */
export const getAuth = () => getServerSession(authConfig);
```

### 8. Update Prisma Schema for Password Authentication

Update the `prisma/schema.prisma` file to include a password field for the User model:

```prisma
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?   // Add this field for password storage
  accounts      Account[]
  sessions      Session[]
  // ... other relations
}
```

Generate and apply the migration:

```bash
npm run db:generate
npm run db:migrate
```

### 9. Install bcryptjs for Password Hashing

```bash
npm install bcryptjs
npm install --save-dev @types/bcryptjs
```

### 10. Create Authentication UI Components

Create the sign-in page at `src/app/auth/signin/page.tsx`:

```tsx
"use client";

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";

import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

const emailSchema = z.object({
  email: z.string().email({ message: "Please enter a valid email address" }),
});

const credentialsSchema = z.object({
  email: z.string().email({ message: "Please enter a valid email address" }),
  password: z.string().min(6, {
    message: "Password must be at least 6 characters",
  }),
});

export default function SignInPage() {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [authError, setAuthError] = useState<string | null>(null);

  const emailForm = useForm<z.infer<typeof emailSchema>>({
    resolver: zodResolver(emailSchema),
    defaultValues: {
      email: "",
    },
  });

  const credentialsForm = useForm<z.infer<typeof credentialsSchema>>({
    resolver: zodResolver(credentialsSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  async function onMagicLinkSubmit(values: z.infer<typeof emailSchema>) {
    setIsLoading(true);
    setAuthError(null);

    try {
      const result = await signIn("email", {
        email: values.email,
        redirect: false,
        callbackUrl: "/dashboard",
      });

      if (result?.error) {
        setAuthError("Failed to send magic link. Please try again.");
      } else {
        router.push("/auth/verify-request");
      }
    } catch (error) {
      setAuthError("An unexpected error occurred. Please try again.");
    } finally {
      setIsLoading(false);
    }
  }

  async function onCredentialsSubmit(
    values: z.infer<typeof credentialsSchema>,
  ) {
    setIsLoading(true);
    setAuthError(null);

    try {
      const result = await signIn("credentials", {
        email: values.email,
        password: values.password,
        redirect: false,
        callbackUrl: "/dashboard",
      });

      if (result?.error) {
        setAuthError("Invalid email or password");
      } else {
        router.push("/dashboard");
      }
    } catch (error) {
      setAuthError("An unexpected error occurred. Please try again.");
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <div className="flex h-screen items-center justify-center">
      <Card className="w-[400px]">
        <CardHeader>
          <CardTitle>Sign In to NoteMomad</CardTitle>
          <CardDescription>
            Choose your preferred sign-in method
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Tabs defaultValue="magic-link">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="magic-link">Magic Link</TabsTrigger>
              <TabsTrigger value="credentials">Password</TabsTrigger>
            </TabsList>

            <TabsContent value="magic-link">
              <Form {...emailForm}>
                <form
                  onSubmit={emailForm.handleSubmit(onMagicLinkSubmit)}
                  className="space-y-4"
                >
                  <FormField
                    control={emailForm.control}
                    name="email"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Email</FormLabel>
                        <FormControl>
                          <Input
                            placeholder="your.email@example.com"
                            type="email"
                            autoCapitalize="none"
                            autoComplete="email"
                            autoCorrect="off"
                            disabled={isLoading}
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  {authError && (
                    <p className="text-destructive text-sm font-medium">
                      {authError}
                    </p>
                  )}

                  <Button type="submit" className="w-full" disabled={isLoading}>
                    {isLoading ? "Sending..." : "Send Magic Link"}
                  </Button>
                </form>
              </Form>
            </TabsContent>

            <TabsContent value="credentials">
              <Form {...credentialsForm}>
                <form
                  onSubmit={credentialsForm.handleSubmit(onCredentialsSubmit)}
                  className="space-y-4"
                >
                  <FormField
                    control={credentialsForm.control}
                    name="email"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Email</FormLabel>
                        <FormControl>
                          <Input
                            placeholder="your.email@example.com"
                            type="email"
                            autoCapitalize="none"
                            autoComplete="email"
                            autoCorrect="off"
                            disabled={isLoading}
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={credentialsForm.control}
                    name="password"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Password</FormLabel>
                        <FormControl>
                          <Input
                            placeholder="••••••••"
                            type="password"
                            autoComplete="current-password"
                            disabled={isLoading}
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  {authError && (
                    <p className="text-destructive text-sm font-medium">
                      {authError}
                    </p>
                  )}

                  <Button type="submit" className="w-full" disabled={isLoading}>
                    {isLoading ? "Signing in..." : "Sign In"}
                  </Button>
                </form>
              </Form>
            </TabsContent>
          </Tabs>
        </CardContent>
        <CardFooter className="flex justify-center">
          <p className="text-muted-foreground text-sm">
            Don't have an account?{" "}
            <Button
              variant="link"
              className="p-0"
              onClick={() => router.push("/auth/signup")}
            >
              Sign up
            </Button>
          </p>
        </CardFooter>
      </Card>
    </div>
  );
}
```

Create a verification request page at `src/app/auth/verify-request/page.tsx`:

```tsx
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

export default function VerifyRequestPage() {
  return (
    <div className="flex h-screen items-center justify-center">
      <Card className="w-[400px]">
        <CardHeader>
          <CardTitle>Check your email</CardTitle>
          <CardDescription>
            A sign in link has been sent to your email address.
          </CardDescription>
        </CardHeader>
        <CardContent className="text-center">
          <p className="text-muted-foreground text-sm">
            Please check your email for a sign in link. This link will expire in
            10 minutes.
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
```

Create a sign-up page at `src/app/auth/signup/page.tsx`:

```tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";

import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

const signupSchema = z
  .object({
    name: z.string().min(2, { message: "Name must be at least 2 characters" }),
    email: z.string().email({ message: "Please enter a valid email address" }),
    password: z.string().min(6, {
      message: "Password must be at least 6 characters",
    }),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
  });

export default function SignUpPage() {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const form = useForm<z.infer<typeof signupSchema>>({
    resolver: zodResolver(signupSchema),
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
  });

  async function onSubmit(values: z.infer<typeof signupSchema>) {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: values.name,
          email: values.email,
          password: values.password,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        setError(data.error || "Something went wrong. Please try again.");
        return;
      }

      router.push("/auth/signin");
    } catch (error) {
      setError("An unexpected error occurred. Please try again.");
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <div className="flex h-screen items-center justify-center">
      <Card className="w-[400px]">
        <CardHeader>
          <CardTitle>Create an Account</CardTitle>
          <CardDescription>
            Sign up for NoteMomad to start managing your notes and meetings.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Name</FormLabel>
                    <FormControl>
                      <Input
                        placeholder="John Doe"
                        disabled={isLoading}
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input
                        placeholder="your.email@example.com"
                        type="email"
                        autoCapitalize="none"
                        autoComplete="email"
                        autoCorrect="off"
                        disabled={isLoading}
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Password</FormLabel>
                    <FormControl>
                      <Input
                        placeholder="••••••••"
                        type="password"
                        autoComplete="new-password"
                        disabled={isLoading}
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="confirmPassword"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Confirm Password</FormLabel>
                    <FormControl>
                      <Input
                        placeholder="••••••••"
                        type="password"
                        autoComplete="new-password"
                        disabled={isLoading}
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {error && (
                <p className="text-destructive text-sm font-medium">{error}</p>
              )}

              <Button type="submit" className="w-full" disabled={isLoading}>
                {isLoading ? "Creating Account..." : "Create Account"}
              </Button>
            </form>
          </Form>
        </CardContent>
        <CardFooter className="flex justify-center">
          <p className="text-muted-foreground text-sm">
            Already have an account?{" "}
            <Button
              variant="link"
              className="p-0"
              onClick={() => router.push("/auth/signin")}
            >
              Sign in
            </Button>
          </p>
        </CardFooter>
      </Card>
    </div>
  );
}
```

### 11. Create a Registration API Endpoint

Create the registration endpoint at `src/app/api/auth/register/route.ts`:

```typescript
import { NextResponse } from "next/server";
import { z } from "zod";
import bcrypt from "bcryptjs";

import { db } from "@/server/db";

const registerSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  password: z.string().min(6),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();

    const result = registerSchema.safeParse(body);
    if (!result.success) {
      return NextResponse.json(
        { error: "Invalid input data", details: result.error.flatten() },
        { status: 400 },
      );
    }

    const { name, email, password } = result.data;

    // Check if user already exists
    const existingUser = await db.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return NextResponse.json(
        { error: "User with this email already exists" },
        { status: 409 },
      );
    }

    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create the user
    const user = await db.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
      },
    });

    // Remove password from the response
    const { password: _, ...userWithoutPassword } = user;

    return NextResponse.json(
      { user: userWithoutPassword, message: "User created successfully" },
      { status: 201 },
    );
  } catch (error) {
    console.error("Registration error:", error);
    return NextResponse.json(
      { error: "Something went wrong. Please try again." },
      { status: 500 },
    );
  }
}
```

### 12. Create Auth Protection Middleware

Create a middleware to protect routes at `src/middleware.ts`:

```typescript
import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";
import { type NextRequest } from "next/server";

export default async function middleware(req: NextRequest) {
  const token = await getToken({ req });
  const isAuthenticated = !!token;

  // Define paths that require authentication
  const authRequiredPaths = ["/dashboard", "/meetings", "/notes"];

  // Define authentication-related paths
  const authPaths = ["/auth/signin", "/auth/signup", "/auth/verify-request"];

  // Check if the current path requires authentication
  const isAuthRequired = authRequiredPaths.some((path) =>
    req.nextUrl.pathname.startsWith(path),
  );

  // Check if the current path is an authentication path
  const isAuthPath = authPaths.some((path) =>
    req.nextUrl.pathname.startsWith(path),
  );

  // If the path requires authentication and the user is not authenticated,
  // redirect to the sign-in page
  if (isAuthRequired && !isAuthenticated) {
    const signInUrl = new URL("/auth/signin", req.url);
    signInUrl.searchParams.set("callbackUrl", req.nextUrl.pathname);
    return NextResponse.redirect(signInUrl);
  }

  // If the user is authenticated and trying to access an authentication page,
  // redirect to the dashboard
  if (isAuthenticated && isAuthPath) {
    return NextResponse.redirect(new URL("/dashboard", req.url));
  }

  // If the user is not authenticated and trying to access the root path,
  // redirect to the sign-in page
  if (!isAuthenticated && req.nextUrl.pathname === "/") {
    return NextResponse.redirect(new URL("/auth/signin", req.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - images (public images folder)
     * - API routes
     */
    "/((?!_next/static|_next/image|favicon.ico|images|api).*)",
  ],
};
```

### 13. Create Auth Session Provider

Create a session provider component at `src/components/providers/session-provider.tsx`:

```tsx
"use client";

import { SessionProvider as NextAuthSessionProvider } from "next-auth/react";

export function SessionProvider({ children }: { children: React.ReactNode }) {
  return <NextAuthSessionProvider>{children}</NextAuthSessionProvider>;
}
```

Update your root layout to include the SessionProvider in `src/app/layout.tsx`:

```tsx
import { ThemeProvider } from "@/components/theme-provider";
import { SessionProvider } from "@/components/providers/session-provider";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head />
      <body>
        <SessionProvider>
          <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          >
            {children}
          </ThemeProvider>
        </SessionProvider>
      </body>
    </html>
  );
}
```

### 14. Install Required Dependencies

```bash
# React Hook Form for form handling
npm install react-hook-form

# Zod resolver for React Hook Form
npm install @hookform/resolvers
```

## Verification

To verify your authentication setup:

1. Start the development server:

```bash
npm run dev
```

2. Navigate to the sign-up page and create a new account.

3. Try signing in with the created account using both credential authentication and magic link authentication.

4. Verify that unauthenticated users are redirected to the sign-in page when trying to access protected routes.

## Troubleshooting

### Email Sending Issues

- Verify that your Resend API key is correct.
- Check the Resend dashboard for error messages.
- Ensure that the email templates are properly formatted.

### Authentication Issues

- Check browser console for errors.
- Verify that the NextAuth.js configuration is correct.
- Check the database to see if users are being created correctly.

### Route Protection Issues

- Check that the middleware is properly configured.
- Verify that the session provider is properly set up.

## Next Steps

After setting up authentication, you can proceed to build the core functionality of your NoteMomad application:

1. Create a dashboard page
2. Implement the meeting management feature
3. Build the note-taking functionality with BlockNote.js
4. Develop the to-do list feature
5. Integrate with LLMs for summarizing meeting transcripts and notes
